Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree-2gb.dts
===================================================================
--- /dev/null
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree-2gb.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * Copyright (c) 2024 FydeOS team
+ */
+
+/dts-v1/;
+
+#include "rtd1619b-teethree.dtsi"
+
+/ {
+  compatible = "realtek,bleeding-edge", "realtek,rtd1619b";
+  model = "Realtek Bleeding Edge XpressReal(2GB)";
+
+  memory@40000 {
+    device_type = "memory";
+    reg = <0x00040000 0x7ffc0000>; /* 2 GB */
+  };
+};
Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree.dtsi
===================================================================
--- /dev/null
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree.dtsi
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * Copyright (c) 2024 FydeOS team.
+ */
+
+#include "rtd1619b-bleedingedge.dtsi"
+
+/ {
+  vcc5v0_sys: vcc5v0-sys {
+    compatible = "regulator-fixed";
+    regulator-name = "vcc5v0_sys";
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-min-microvolt = <5000000>;
+    regulator-max-microvolt = <5000000>;
+  };
+};
+
+&display_subsystem {
+	ports = <&vo0_out>;
+};
+
+&vo0 {
+  status = "okay";
+};
+
+&vo1 {
+  status = "disabled";
+  vo1_out: port {
+    vo1_out_dsi: endpoint {
+      remote-endpoint = <&dsi_in_vo1>;
+    };
+  };
+};
+
+&vo2 {
+  status = "disabled";
+};
+
+&hdmi {
+	hdmi5v-gpios = <&gpio 5 GPIO_ACTIVE_HIGH>;
+	ext-flags = <0x0>;
+};
+
+&dsi {
+  status = "disabled";
+};
+
+&sfc {
+  status = "okay";
+  max-freq = <50000000>;
+  #address-cells = <1>;
+  #size-cells = <0>;
+  pinctrl-names = "default";
+  pinctrl-0 = <&spi_pins_loc_spi>;
+};
+
+&rfkill {
+  rfkill-gpios = <&gpio 57 GPIO_ACTIVE_HIGH>;
+  voltage-config = <1>;
+	status = "okay";
+};
+
+&sdio {
+  pinctrl-names = "default",
+    "sdio-3v3-drv",
+    "sdio-1v8-drv",
+    "sdio-vsel-3v3",
+    "sdio-vsel-1v8";
+  pinctrl-0 = <&sdio_pins_1>;
+  pinctrl-1 = <&sdio_pins_1_3v3_drv>;
+  pinctrl-2 = <&sdio_pins_1_1v8_drv>;
+  pinctrl-3 = <&sdio_pins_1_vsel_3v3>;
+  pinctrl-4 = <&sdio_pins_1_vsel_1v8>;
+  wifi-rst-gpios = <&gpio 61 GPIO_ACTIVE_HIGH>;
+};
+
+&usb_port0 {
+  realtek,power-gpio = <&gpio 48 GPIO_ACTIVE_HIGH>;
+};
+
+&usb_port1 {
+	realtek,power-gpio = <&gpio 48 GPIO_ACTIVE_HIGH>;
+};
+
+&uart1 {
+  cts-gpios = <&gpio 10 GPIO_ACTIVE_LOW>;
+  rts-gpios = <&gpio 11 GPIO_ACTIVE_LOW>;
+  pinctrl-0 = <&uart1_pins &uart1_cts_rts>;
+  snps,uart-16550-compatible;
+  current-speed = <1500000>;
+  status = "okay";
+};
+
+&pinctrl {
+  aic8800_wifi {
+     bt_enable_h: bt-enable-h {
+       pins = "gpio_57";
+       function = "gpio";
+       bias-disable;
+     };
+  };
+
+  uart1_cts_rts: uart1-cts-rts {
+    pins = "gpio_10", "gpio_11";
+    function = "gpio";
+    bias-pull-down;
+  };
+
+  sdio_pins_1_3v3_drv: sdio-pins-1-3v3-drv {
+    pins = "gpio_40", "gpio_41", "gpio_42", "gpio_43", "gpio_44", "gpio_45";
+    function = "sdio_loc1";
+    realtek,pdrive = <0>;
+    realtek,ndrive = <0>;
+  };
+
+  sdio_pins_1_1v8_drv: sdio-pins-1-1v8-drv {
+    pins = "gpio_40", "gpio_41", "gpio_42", "gpio_43", "gpio_44", "gpio_45";
+    function = "sdio_loc1";
+    realtek,pdrive = <4>;
+    realtek,ndrive = <4>;
+  };
+
+  sdio_pins_1_vsel_3v3: sdio-pins-1-vsel-3v3 {
+    pins = "gpio_40", "gpio_41", "gpio_42", "gpio_43", "gpio_44", "gpio_45";
+    function = "sdio_loc1";
+    power-source = <1>;
+  };
+
+  sdio_pins_1_vsel_1v8: sdio-pins-1-vsel-1v8 {
+    pins = "gpio_40", "gpio_41", "gpio_42", "gpio_43", "gpio_44", "gpio_45";
+    function = "sdio_loc1";
+    power-source = <0>;
+  };
+};
+
+&sd {
+  disable-wp;
+};
Index: kernel-5_15/arch/arm64/boot/dts/realtek/Makefile
===================================================================
--- kernel-5_15.orig/arch/arm64/boot/dts/realtek/Makefile
+++ kernel-5_15/arch/arm64/boot/dts/realtek/Makefile
@@ -70,3 +70,6 @@ dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-b
 dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-bleedingedge-4gb.dtb
 dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-rescue-nand.dtb
 dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-rescue.dtb
+
+dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-teethree-2gb.dtb
+dtb-$(CONFIG_ARCH_REALTEK) += rtd1619b-teethree-4gb.dtb
Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree-4gb.dts
===================================================================
--- /dev/null
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-teethree-4gb.dts
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * Copyright (c) 2024 FydeOS team
+ */
+
+/dts-v1/;
+
+#include "rtd1619b-teethree.dtsi"
+
+/ {
+  compatible = "realtek,bleeding-edge", "realtek,rtd1619b";
+  model = "Realtek Bleeding Edge XpressReal(4GB)";
+
+  memory@40000 {
+    device_type = "memory";
+    reg = <0x00040000 0x7ffc0000>,
+          <0x80020000 0x080e0000>,
+          <0x8a100000 0x0defc000>,
+          <0x98200000 0x00df0000>,
+          <0x99000000 0x07000000>,
+          <0xa0200000 0x5ee00000>;
+  };
+};
Index: kernel-5_15/drivers/mmc/host/sdhci-rtk.c
===================================================================
--- kernel-5_15.orig/drivers/mmc/host/sdhci-rtk.c
+++ kernel-5_15/drivers/mmc/host/sdhci-rtk.c
@@ -5,34 +5,29 @@
  * Copyright (c) 2017-2020 Realtek Semiconductor Corp.
  */
 
-#include <linux/utsname.h>
-#include <linux/module.h>
-#include <linux/init.h>
+#include <linux/bitfield.h>
 #include <linux/delay.h>
-#include <linux/reset.h>
 #include <linux/err.h>
+#include <linux/init.h>
 #include <linux/io.h>
-#include <linux/of_address.h>
-#include <linux/of_device.h>
-#include <linux/of_gpio.h>
-#include <linux/bitfield.h>
-#include <linux/mmc/mmc.h>
 #include <linux/mmc/card.h>
-#include <linux/mmc/sdio.h>
-#include <linux/mmc/sd.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
 #include <linux/mmc/slot-gpio.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/reset.h>
 #include <linux/sys_soc.h>
+#include <linux/utsname.h>
 
 #include "sdhci-pltfm.h"
 #include "sdhci-rtk.h"
 
-#define DRIVER_NAME		"Realtek SDIO"
-
-#define MAX_PHASE		32
-#define TUNING_CNT		3
-#define MINIMUM_CONTINUE_LENGTH	16
-
 #define BOUNDARY_OK(addr, len) \
 	((addr | (SZ_4K - 1)) == ((addr + len - 1) | (SZ_4K - 1)))
 
@@ -43,11 +38,18 @@ struct sdhci_rtk_soc_data {
 
 struct sdhci_rtk {
 	const struct sdhci_rtk_soc_data *soc_data;
-	struct gpio_desc *sdio_rst;
+	struct gpio_desc *wifi_rst;
+	struct gpio_desc *sd_pwr_gpio;
 	struct clk *clk_en_sdio;
 	struct clk *clk_en_sdio_ip;
 	struct reset_control *rstc_sdio;
 	void __iomem *crt_membase;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_3v3_drv;
+	struct pinctrl_state *pins_1v8_drv;
+	struct pinctrl_state *pins_vsel_3v3;
+	struct pinctrl_state *pins_vsel_1v8;
 	unsigned int preset_pll;
 	int location;
 };
@@ -82,61 +84,90 @@ static const struct soc_device_attribute
 	{ /* sentinel */ }
 };
 
-static void rtk_sdhci_set_cmd_timeout_irq(struct sdhci_host *host, bool enable)
+static void rtk_sdhci_pad_power_ctrl(struct sdhci_host *host, int voltage)
 {
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
+	void __iomem *crt_membase =  rtk_host->crt_membase;
 	u32 reg;
 
-	if (host->mmc->card != NULL)
-		return;
+	switch (voltage) {
+	case MMC_SIGNAL_VOLTAGE_180:
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		reg &= ~REG_SEL3318_MASK;
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		mdelay(1);
 
-	if (enable) {
-		reg = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
-		if (!(reg & SDHCI_INT_TIMEOUT))
-			host->ier |= SDHCI_INT_TIMEOUT;
-		else
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		reg |= FIELD_PREP(REG_SEL3318_MASK, REG_SEL3318_0V);
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		mdelay(1);
+
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		reg |= FIELD_PREP(REG_SEL3318_MASK, REG_SEL3318_1V8);
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		mdelay(1);
+
+		pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_vsel_1v8);
+
+		break;
+	case MMC_SIGNAL_VOLTAGE_330:
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		if (FIELD_GET(REG_SEL3318_MASK, reg) == REG_SEL3318_3V3)
 			return;
-	} else {
-		host->ier &= ~SDHCI_INT_TIMEOUT;
-		del_timer(&host->timer);
-	}
 
-	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+		reg &= ~FIELD_PREP(REG_SEL3318_MASK, REG_SEL3318_3V3);
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		mdelay(1);
+
+		pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_vsel_3v3);
+		mdelay(1);
+
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		reg &= ~REG_SEL3318_MASK;
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		mdelay(1);
+
+		reg = readl(crt_membase + SYS_PLL_SD1);
+		reg |= FIELD_PREP(REG_SEL3318_MASK, REG_SEL3318_3V3);
+		writel(reg, crt_membase + SYS_PLL_SD1);
+		break;
+	}
 }
 
-static void rtk_sdhci_pad_power_ctrl(struct sdhci_host *host, int voltage)
+/*
+ * The sd_reset pin of Realtek sdio wifi connects to the specific gpio of SoC.
+ * Toggling this gpio will reset the SDIO interface of Realtek wifi devices.
+ */
+static void rtk_sdhci_wifi_device_reset(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
-	void __iomem *crt_membase =  rtk_host->crt_membase;
+	struct device *dev = mmc_dev(host->mmc);
 
-	switch (voltage) {
+	if (gpiod_direction_output(rtk_host->wifi_rst, 0))
+		dev_err(dev, "fail to set sd reset gpio low\n");
 
-	case MMC_SIGNAL_VOLTAGE_180:
-		if (soc_device_match(rtk_soc_stark)) {
-			writel((readl(crt_membase + 0x4E068) & 0xffbfffff), crt_membase + 0x4E068);
-			writel((readl(crt_membase + 0x4E06c) & 0xfdffefff), crt_membase + 0x4E06c);
-			writel((readl(crt_membase + 0x4E070) & 0xfdffefff), crt_membase + 0x4E070);
-			writel((readl(crt_membase + 0x4E074) & 0xffffffbf), crt_membase + 0x4E074);
-		} else if (soc_device_match(rtk_soc_parker)) {
-			writel((readl(crt_membase + 0x4E03c) & 0xdffeffff), crt_membase + 0x4E03c);
-			writel((readl(crt_membase + 0x4E040) & 0xfdffefff), crt_membase + 0x4E040);
-			writel((readl(crt_membase + 0x4E044) & 0xfdffefff), crt_membase + 0x4E044);
-		}
-		break;
-	case MMC_SIGNAL_VOLTAGE_330:
-		if (soc_device_match(rtk_soc_stark)) {
-			writel((readl(crt_membase + 0x4E068) | 0x00400000), crt_membase + 0x4E068);
-			writel((readl(crt_membase + 0x4E06c) | 0x02001000), crt_membase + 0x4E06c);
-			writel((readl(crt_membase + 0x4E070) | 0x02001000), crt_membase + 0x4E070);
-			writel((readl(crt_membase + 0x4E074) | 0x00000040), crt_membase + 0x4E074);
-		} else if (soc_device_match(rtk_soc_parker)) {
-			writel((readl(crt_membase + 0x4E03c) | 0x20010000), crt_membase + 0x4E03c);
-			writel((readl(crt_membase + 0x4E040) | 0x02001000), crt_membase + 0x4E040);
-			writel((readl(crt_membase + 0x4E044) | 0x02001000), crt_membase + 0x4E044);
-		}
-		break;
-	}
+	mdelay(150);
+
+	if (gpiod_direction_input(rtk_host->wifi_rst))
+		dev_err(dev, "wifi reset fail\n");
+}
+
+static void rtk_sdhci_set_cmd_timeout_irq(struct sdhci_host *host, bool enable)
+{
+	if (host->mmc->card != NULL)
+		return;
+
+	if (enable)
+		host->ier |= SDHCI_INT_TIMEOUT;
+	else
+		host->ier &= ~SDHCI_INT_TIMEOUT;
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
 }
+
 static void rtk_sdhci_pad_driving_configure(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
@@ -147,21 +178,12 @@ static void rtk_sdhci_pad_driving_config
 		writel((readl(crt_membase + 0x4E024) & 0xf) | 0xAF75EEB0, crt_membase + 0x4E024);
 		writel(0x5EEBDD7B, crt_membase + 0x4E028);
 		writel((readl(crt_membase + 0x4E02c) & 0xffffffc0) | 0x37, crt_membase + 0x4E02c);
-	} else if (soc_device_match(rtk_soc_groot) || soc_device_match(rtk_soc_hank)) {
-		writel((readl(crt_membase + 0x4E058) & 0xff000000) | 0x00483483, crt_membase + 0x4E058);
-		writel((readl(crt_membase + 0x4E05c) & 0xff000000) | 0x00483483, crt_membase + 0x4E05c);
-		writel((readl(crt_membase + 0x4E060) & 0xff000000) | 0x00483483, crt_membase + 0x4E060);
-	} else if (soc_device_match(rtk_soc_stark)) {
-		writel((readl(crt_membase + 0x4E068) & 0xff80ffff) | 0x00240000, crt_membase + 0x4E068);
-		writel((readl(crt_membase + 0x4E06c) & 0xfc07e03f) | 0x01200900, crt_membase + 0x4E06c);
-		writel((readl(crt_membase + 0x4E070) & 0xfc07e03f) | 0x01200900, crt_membase + 0x4E070);
-		writel((readl(crt_membase + 0x4E074) & 0xffffff80) | 0x00000024, crt_membase + 0x4E074);
-	} else if (soc_device_match(rtk_soc_parker)) {
-		writel((readl(crt_membase + 0x4E03c) & 0xe07f03ff) | 0x12009000, crt_membase + 0x4E03c);
-		writel((readl(crt_membase + 0x4E040) & 0xfe07f03f) | 0x01200900, crt_membase + 0x4E040);
-		writel((readl(crt_membase + 0x4E044) & 0xfe07f03f) | 0x01200900, crt_membase + 0x4E044);
+	} else {
+		if (host->timing > MMC_TIMING_SD_HS)
+			pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_1v8_drv);
+		else
+			pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_3v3_drv);
 	}
-
 }
 
 static void rtk_sdhci_pll_configure(struct sdhci_host *host, u32 pll, int execute_tuning)
@@ -169,23 +191,32 @@ static void rtk_sdhci_pll_configure(stru
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
 	void __iomem *crt_membase =  rtk_host->crt_membase;
+	u32 val;
 
-	u32 sscpll;
+	writel(0x00000006, crt_membase + SYS_PLL_SDIO4);
 
-	writel(0x00000006, crt_membase + 0x01AC);
-	if (soc_device_match(rtk_soc_stark))
-		sscpll = 0x0451742d;
-	else if (soc_device_match(rtk_soc_parker))
-		sscpll = 0x078d742c;
-	else
-		sscpll = 0x04517893;
+	val = FIELD_PREP(REG_TUNE11, REG_TUNE11_1V9) |
+	      FIELD_PREP(SSCPLL_CS1, SSCPLL_CS1_INIT_VALUE) |
+	      FIELD_PREP(SSC_DEPTH, SSC_DEPTH_1_N) |
+	      SSC_8X_EN |
+	      FIELD_PREP(SSC_DIV_EXT_F, SSC_DIV_EXT_F_200M) |
+	      EN_CPNEW;
+
+	if (soc_device_match(rtk_soc_parker) || soc_device_match(rtk_soc_stark)) {
+		val |= FIELD_PREP(SSCPLL_ICP, SSCPLL_ICP_10U) |
+		       FIELD_PREP(SSCPLL_RS, SSCPLL_RS_13K);
+	} else {
+		val |= FIELD_PREP(SSCPLL_ICP, SSCPLL_ICP_20U) |
+		       FIELD_PREP(SSCPLL_RS, SSCPLL_RS_10K);
+	}
 
 	/* The SSC shouldn't enable when execute tuning */
 	if (!execute_tuning)
-		writel(sscpll, crt_membase + 0x01A4);
-	writel(pll, crt_membase + 0x01A8);
+		writel(val, crt_membase + SYS_PLL_SDIO2);
+
+	writel(pll, crt_membase + SYS_PLL_SDIO3);
 	mdelay(2);
-	writel(0x00000007, crt_membase + 0x01AC);
+	writel(0x00000007, crt_membase + SYS_PLL_SDIO4);
 	udelay(200);
 }
 
@@ -194,64 +225,20 @@ static void sdhci_rtk_sd_slot_init(struc
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
 	void __iomem *crt_membase =  rtk_host->crt_membase;
+	struct device *dev = mmc_dev(host->mmc);
+
+	if (soc_device_match(rtk_soc_stark)) {
+
+		if (gpiod_direction_output(rtk_host->sd_pwr_gpio, 0))
+			dev_err(dev, "fail to enable sd power");
 
-	if (soc_device_match(rtk_soc_thor)) {
-		writel(readl(crt_membase + 0x4E004) & (~(0x1 << 25)), crt_membase + 0x4E004);
-		writel((readl(crt_membase + 0x4E020) & 0xff0fffff) | 0x00600000, crt_membase + 0x4E020);
-		mdelay(100);
-
-		writel(readl(crt_membase + 0x4E020) & 0xffbfffff, crt_membase + 0x4E020);
-		mdelay(100);
-
-		writel((readl(crt_membase + 0x4f00c) & 0xf) | (0x3243243 << 4), crt_membase + 0x4f00c);
-		writel(0xd83d83d8, crt_membase + 0x4f010);
-
-		writel((readl(crt_membase + 0x4f014) & 0xfffff000) | 0xd83, crt_membase + 0x4f014);
-		writel(0x10, crt_membase + 0x4E048);
-		writel((readl(crt_membase + 0x4F004) & 0xfff00000) | 0x52492, crt_membase + 0x4F004);
-		writel(0x3, crt_membase + 0x1e0);
-		writel(0x4003, crt_membase + 0x1e0);
-		writel(0x6003, crt_membase + 0x1e0);
-	} else if (soc_device_match(rtk_soc_hank)) {
-		writel(readl(crt_membase + 0x4E00C) & (~(0x1 << 2)), crt_membase + 0x4E00C);
-		writel((readl(crt_membase + 0x4E048) & 0xfff0ffff) | 0x00060000, crt_membase + 0x4E048);
-		mdelay(100);
-
-		writel(readl(crt_membase + 0x4E048) & 0xfffbffff, crt_membase + 0x4E048);
-		mdelay(100);
-		writel((readl(crt_membase + 0x4E04C) & 0xff000000) | 0x243243, crt_membase + 0x4E04C);
-		writel((readl(crt_membase + 0x4E050) & 0xf000000f) | (0x243243 << 4), crt_membase + 0x4E050);
-		writel((readl(crt_membase + 0x4E054) & 0xff000000) | 0x243243, crt_membase + 0x4E054);
-
-		writel((readl(crt_membase + 0x4E010) & 0xfffffff0) | (0x1 << 1), crt_membase + 0x4E010);
-		writel(0x10, crt_membase + 0x4E120);
-		writel((readl(crt_membase + 0x4E00C) & 0xf00f) | 0x04440480, crt_membase + 0x4E00C);
-		writel(0x3, crt_membase + 0x1e0);
-		writel(0x4003, crt_membase + 0x1e0);
-		writel(0x6003, crt_membase + 0x1e0);
-	} else if (soc_device_match(rtk_soc_stark)) {
-		writel(readl(crt_membase + 0x7100) | (0x1 << 30), crt_membase + 0x7100);
-		writel(readl(crt_membase + 0x7104) | (0x0 << 30), crt_membase + 0x7104);
 		writel((readl(crt_membase + 0x4E080) & 0xfffFBfff) | 0x00004000, crt_membase + 0x4E080);
 		mdelay(10);
 
-		writel((readl(crt_membase + 0x4E078) & 0xfe07f03f) | 0x00d806c0, crt_membase + 0x4E078);
-		writel((readl(crt_membase + 0x4E07c) & 0xfff81fc0) | 0x0003601b, crt_membase + 0x4E07c);
-		writel((readl(crt_membase + 0x4E080) & 0xfe07f03f) | 0x00d806c0, crt_membase + 0x4E080);
-
-		writel((readl(crt_membase + 0x4E00c) & 0xff801fff) | 0x00084000, crt_membase + 0x4E00c);
-		writel((readl(crt_membase + 0x4E010) & 0xfff80000) | 0x00008842, crt_membase + 0x4E010);
-		writel(0x10, crt_membase + 0x4E120);
-
-		writel((readl(crt_membase+0x1e0) & 0xffff9fff), crt_membase+0x1e0);
-		mdelay(1);
-		writel((readl(crt_membase+0x1e0) | 0x00004000), crt_membase+0x1e0);
-		mdelay(1);
-		writel((readl(crt_membase+0x1e0) | 0x00006000), crt_membase+0x1e0);
-		mdelay(1);
-		writel((readl(crt_membase + 0x4E078) & 0xfdffefff), crt_membase + 0x4E078);
-		writel((readl(crt_membase + 0x4E07c) & 0xfff7ffbf), crt_membase + 0x4E07c);
-		writel((readl(crt_membase + 0x4E080) & 0xfdffefff), crt_membase + 0x4E080);
+		if (host->quirks2 & SDHCI_QUIRK2_NO_1_8_V)
+			rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_330);
+		else
+			rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_180);
 	}
 }
 
@@ -260,10 +247,11 @@ static void sdhci_rtk_hw_init(struct sdh
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
 	void __iomem *crt_membase =  rtk_host->crt_membase;
+	u32 val;
 
 	if (soc_device_match(rtk_soc_thor_a01)) {
-		writel(readl(crt_membase + 0x1A0) | 0x1, crt_membase + 0x1A0);
-		writel(readl(crt_membase + 0x1A4) | 0x1, crt_membase + 0x1A4);
+		writel(readl(crt_membase + SYS_PLL_SDIO1) | 0x1, crt_membase + SYS_PLL_SDIO1);
+		writel(readl(crt_membase + SYS_PLL_SDIO2) | 0x1, crt_membase + SYS_PLL_SDIO2);
 		udelay(200);
 	} else if (soc_device_match(rtk_soc_groot) || soc_device_match(rtk_soc_hank)) {
 		writel(readl(crt_membase + 0x7064) | (0x3 << 4), crt_membase + 0x7064);
@@ -273,37 +261,26 @@ static void sdhci_rtk_hw_init(struct sdh
 		udelay(200);
 	}
 
-	rtk_sdhci_pll_configure(host, 0x00ae4388, 0);
-
-	if (soc_device_match(rtk_soc_groot) || soc_device_match(rtk_soc_hank))
-		writel(readl(crt_membase + 0x10A58) | 0x80000000, crt_membase + 0x10A58);
-
-	writel(0x00000011, crt_membase + 0x010A34);
-	writel(0x00000001, crt_membase + 0x010A10);
-}
-
-void rtk_sdhci_platform_init(struct sdhci_host *host)
-{
-	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
-	void __iomem *crt_membase =  rtk_host->crt_membase;
-
-	/*  The VDD resistor set 1.8v as default */
-	if (soc_device_match(rtk_soc_stark)) {
-		rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_180);
-	} else if (soc_device_match(rtk_soc_parker)) {
-		writel(readl(crt_membase + 0x4E190) | (0x1 << 5), crt_membase + 0x4E190);
-		udelay(100);
-		if (readl(crt_membase + 0x4E190) & 0x4)
-			rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_330);
+	if (rtk_host->location == SDIO_LOC_0) {
+		sdhci_rtk_sd_slot_init(host);
+	} else if (soc_device_match(rtk_soc_stark)) {
+		if (host->quirks2 & SDHCI_QUIRK2_NO_1_8_V)
+			pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_vsel_3v3);
 		else
-			rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_180);
+			pinctrl_select_state(rtk_host->pinctrl, rtk_host->pins_vsel_1v8);
 	}
 
-	sdhci_rtk_hw_init(host);
+	val = FIELD_PREP(SSC_TBASE, SSC_TBASE_INIT_VALUE) |
+	      FIELD_PREP(SSC_STEP_IN, SSC_STEP_IN_INIT_VALUE) |
+	      FIELD_PREP(SSC_DIV_N, SSC_DIV_N_200M);
 
-	if (rtk_host->location == 0)
-		sdhci_rtk_sd_slot_init(host);
+	rtk_sdhci_pll_configure(host, val, 0);
+
+	if (soc_device_match(rtk_soc_groot) || soc_device_match(rtk_soc_hank))
+		writel(readl(crt_membase + SDIO_RTK_DUMMY_SYS1) | 0x80000000, crt_membase + SDIO_RTK_DUMMY_SYS1);
+
+	writel(0x00000011, crt_membase + SDIO_RTK_ISREN);
+	writel(0x00000001, crt_membase + SDIO_RTK_CTL);
 }
 
 static void rtk_sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
@@ -324,34 +301,12 @@ static void rtk_sdhci_set_ios(struct mmc
 
 	sdhci_set_ios(mmc, ios);
 
-	switch (host->timing) {
-
-	case MMC_TIMING_SD_HS:
-		if (soc_device_match(rtk_soc_stark))
-			rtk_sdhci_pad_power_ctrl(host, MMC_SIGNAL_VOLTAGE_330);
-		break;
-	case MMC_TIMING_UHS_SDR12:
-	case MMC_TIMING_UHS_SDR25:
-		rtk_sdhci_pad_driving_configure(host);
-		break;
-	case MMC_TIMING_UHS_SDR50:
-		rtk_sdhci_pad_driving_configure(host);
-		sdhci_writew(host, 0x7, SDHCI_CLOCK_CONTROL);
-		rtk_sdhci_pll_configure(host, 0x00564388, 0);
-		break;
-	case MMC_TIMING_UHS_SDR104:
-		rtk_sdhci_pad_driving_configure(host);
-
-		/* enlarge wait time for data */
-		if (soc_device_match(rtk_soc_thor))
-			writel(0x1d, crt_membase + 0x10a58);
+	rtk_sdhci_pad_driving_configure(host);
 
-		if (host->mmc->card->cis.device == 0x0000b822)
-			rtk_sdhci_pll_configure(host, 0x00ae4388, 0);
-		else
-			rtk_sdhci_pll_configure(host, 0x00b64388, 0);
-		break;
-	}
+	/* enlarge wait time for data */
+	if ((host->timing == MMC_TIMING_UHS_SDR104) &&
+	    soc_device_match(rtk_soc_thor))
+		writel(0x1d, crt_membase + SDIO_RTK_DUMMY_SYS1);
 }
 
 static void rtk_sdhci_reset(struct sdhci_host *host, u8 mask)
@@ -360,14 +315,14 @@ static void rtk_sdhci_reset(struct sdhci
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
 	void __iomem *crt_membase =  rtk_host->crt_membase;
 
-	writel(0x00000003, crt_membase + 0x010A10);
+	writel(0x00000003, crt_membase + SDIO_RTK_CTL);
 
 	if (mask & SDHCI_RESET_DATA)
 		sdhci_writel(host, SDHCI_INT_DATA_END, SDHCI_INT_STATUS);
 
 	sdhci_reset(host, mask);
 
-	writel(0x00000001, crt_membase + 0x010A10);
+	writel(0x00000001, crt_membase + SDIO_RTK_CTL);
 }
 
 static u32 rtk_sdhci_irq(struct sdhci_host *host, u32 intmask)
@@ -378,28 +333,27 @@ static u32 rtk_sdhci_irq(struct sdhci_ho
 	if (host->mmc->card != NULL)
 		return intmask;
 
-	command = SDHCI_GET_CMD(sdhci_readw(host, SDHCI_COMMAND));
-	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
-
 	if (host->cmd != NULL) {
 		rtk_sdhci_set_cmd_timeout_irq(host, true);
-
 		return intmask;
+	}
+
+	if (intmask & SDHCI_INT_TIMEOUT) {
+		command = SDHCI_GET_CMD(sdhci_readw(host, SDHCI_COMMAND));
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
 	} else {
-		if (intmask & SDHCI_INT_TIMEOUT) {
-			if (!clk && (command == MMC_GO_IDLE_STATE)) {
-				intmask &= ~SDHCI_INT_TIMEOUT;
-				rtk_sdhci_set_cmd_timeout_irq(host, false);
-			} else if (command == MMC_GO_IDLE_STATE ||
-				   command == SD_SEND_IF_COND ||
-				   command == SD_IO_SEND_OP_COND ||
-				   command == SD_IO_RW_DIRECT ||
-				   command == MMC_APP_CMD ||
-				   command == MMC_SEND_OP_COND) {
-				intmask &= ~SDHCI_INT_TIMEOUT;
-				del_timer(&host->timer);
-			}
-		}
+		return intmask;
+	}
+
+	if (!clk && (command == MMC_GO_IDLE_STATE))
+		rtk_sdhci_set_cmd_timeout_irq(host, false);
+
+	if (command == MMC_GO_IDLE_STATE || command == SD_SEND_IF_COND ||
+	    command == SD_IO_SEND_OP_COND || command == SD_IO_RW_DIRECT ||
+	    command == MMC_APP_CMD || command == MMC_SEND_OP_COND) {
+		intmask &= ~SDHCI_INT_TIMEOUT;
+		sdhci_writel(host, SDHCI_INT_TIMEOUT, SDHCI_INT_STATUS);
+		del_timer(&host->timer);
 	}
 
 	return intmask;
@@ -457,18 +411,18 @@ static int rtk_sdhci_change_phase(struct
 	clk &= ~SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 
-	writel(readl(crt_membase + 0x1A0) & 0xfffffffd, crt_membase + 0x1A0);
+	writel(readl(crt_membase + SYS_PLL_SDIO1) & 0xfffffffd, crt_membase + SYS_PLL_SDIO1);
 
-	temp_reg = readl(crt_membase + 0x1A0);
+	temp_reg = readl(crt_membase + SYS_PLL_SDIO1);
 
 	if (tx)
 		temp_reg = (temp_reg & ~0x000000F8) | (sample_point << 3);
 	else
 		temp_reg = (temp_reg & ~0x00001F00) | (sample_point << 8);
 
-	writel(temp_reg, crt_membase + 0x1A0);
+	writel(temp_reg, crt_membase + SYS_PLL_SDIO1);
 
-	writel(readl(crt_membase + 0x1A0) | 0x2, crt_membase + 0x1A0);
+	writel(readl(crt_membase + SYS_PLL_SDIO1) | 0x2, crt_membase + SYS_PLL_SDIO1);
 
 	udelay(100);
 	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
@@ -573,7 +527,7 @@ static void rtk_sdhci_down_clock(struct
 	void __iomem *crt_membase =  rtk_host->crt_membase;
 	u32 reg, ssc_div_n;
 
-	reg = readl(crt_membase + 0x01A8);
+	reg = readl(crt_membase + SYS_PLL_SDIO3);
 	ssc_div_n = (reg & 0x03FF0000) >> 16;
 	/* When PLL set to 96, may interference wifi 2.4Ghz */
 	if (ssc_div_n == 158)
@@ -592,9 +546,9 @@ static int rtk_sdhci_execute_tuning(stru
 
 	pr_err("%s : Execute Clock Phase Tuning\n", __func__);
 	/* To disable the SSC during the phase tuning process. */
-	reg = readl(crt_membase + 0x01A4);
+	reg = readl(crt_membase + SYS_PLL_SDIO2);
 	reg &= 0xFFFF1FFF;
-	writel(reg, crt_membase + 0x01A4);
+	writel(reg, crt_membase + SYS_PLL_SDIO2);
 
 	if (mmc_card_sdio(host->mmc->card))
 		tx_opcode = SD_IO_RW_DIRECT;
@@ -607,7 +561,7 @@ static int rtk_sdhci_execute_tuning(stru
 
 	do {
 		ret = rtk_sdhci_tuning(host, MMC_SEND_TUNING_BLOCK, 0);
-		reg = readl(crt_membase + 0x01A8);
+		reg = readl(crt_membase + SYS_PLL_SDIO3);
 		ssc_div_n = (reg & 0x03FF0000) >> 16;
 		if (ret) {
 			if (ssc_div_n <= 100) {
@@ -618,9 +572,9 @@ static int rtk_sdhci_execute_tuning(stru
 		}
 	} while (ret);
 
-	reg = readl(crt_membase + 0x01A4);
-	reg |= 0x0000E000;
-	writel(reg, crt_membase + 0x01A4);
+	reg = readl(crt_membase + SYS_PLL_SDIO2);
+	reg |= 0x00006000;
+	writel(reg, crt_membase + SYS_PLL_SDIO2);
 
 	pr_err("After tuning, current SDIO PLL = %x\n", ssc_div_n);
 
@@ -736,10 +690,9 @@ static int sdhci_rtk_probe(struct platfo
 	struct sdhci_host *host;
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_rtk *rtk_host;
-	const u32 *prop;
 	int rc = 0;
 
-	pr_info("%s: build at : %s\n", DRIVER_NAME, utsname()->version);
+	pr_info("%s: build at : %s\n", __func__, utsname()->version);
 
 	match = of_match_device(sdhci_rtk_dt_match, &pdev->dev);
 	if (!match)
@@ -754,36 +707,29 @@ static int sdhci_rtk_probe(struct platfo
 	rtk_host = sdhci_pltfm_priv(pltfm_host);
 	rtk_host->soc_data = soc_data;
 	rtk_host->preset_pll = 0;
-	rtk_host->location = 1;
-
-	sd_node = of_get_compatible_child(node, "sd_slot");
-	if (sd_node) {
-		prop = of_get_property(sd_node, "loc", NULL);
-		if (!prop)
-			dev_err(&pdev->dev, "Could not find location property\n");
-		else
-			rtk_host->location = of_read_number(prop, 1);
-
-		of_node_put(sd_node);
-	}
+	rtk_host->location = SDIO_LOC_1;
 
 	rtk_host->crt_membase = of_iomap(node, 1);
 	if (!rtk_host->crt_membase)
 		return -ENOMEM;
 
-	rtk_host->sdio_rst = devm_gpiod_get(&pdev->dev, "sdio", GPIOD_OUT_LOW);
-	if (IS_ERR(rtk_host->sdio_rst)) {
-		dev_err(&pdev->dev, "sdio gpio missing or invalid\n");
-	} else {
-		if (gpiod_direction_output(rtk_host->sdio_rst, 0))
-			dev_err(&pdev->dev, "fail to set sd reset gpio low\n");
+	sd_node = of_get_compatible_child(node, "sd-slot");
+	if (sd_node) {
+		rtk_host->location = SDIO_LOC_0;
 
-		mdelay(150);
+		rtk_host->sd_pwr_gpio = devm_gpiod_get(&pdev->dev, "sd-power", GPIOD_OUT_LOW);
+		if (IS_ERR(rtk_host->sd_pwr_gpio))
+			dev_err(&pdev->dev, "%s can't request power gpio\n", __func__);
 
-		if (gpiod_direction_input(rtk_host->sdio_rst))
-			dev_err(&pdev->dev, "wifi reset fail\n");
+		of_node_put(sd_node);
 	}
 
+	rtk_host->wifi_rst = devm_gpiod_get(&pdev->dev, "wifi-rst", GPIOD_OUT_LOW);
+	if (IS_ERR(rtk_host->wifi_rst))
+		dev_err(&pdev->dev, "%s rtk wifi reset gpio invalid\n", __func__);
+	else
+		rtk_sdhci_wifi_device_reset(host);
+
 	rtk_host->rstc_sdio = devm_reset_control_get(&pdev->dev, NULL);
 	if (IS_ERR(rtk_host->rstc_sdio)) {
 		pr_warn("Failed to get sdio reset control(%ld)\n", PTR_ERR(rtk_host->rstc_sdio));
@@ -802,14 +748,61 @@ static int sdhci_rtk_probe(struct platfo
 		rtk_host->clk_en_sdio_ip = NULL;
 	}
 
+	rtk_host->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(rtk_host->pinctrl)) {
+		rc = PTR_ERR(rtk_host->pinctrl);
+		pr_err("fail to get pinctrl\n");
+		goto err_sdio_clk;
+	}
+
+	rtk_host->pins_default = pinctrl_lookup_state(rtk_host->pinctrl, PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(rtk_host->pins_default)) {
+		rc = PTR_ERR(rtk_host->pins_default);
+		pr_warn("fail to get default state\n");
+		goto err_sdio_clk;
+	}
+
+	rtk_host->pins_3v3_drv = pinctrl_lookup_state(rtk_host->pinctrl, "sdio-3v3-drv");
+	if (IS_ERR(rtk_host->pins_3v3_drv)) {
+		rc = PTR_ERR(rtk_host->pins_3v3_drv);
+		pr_warn("fail to get pad driving for 3.3V state\n");
+		goto err_sdio_clk;
+	}
+
+	rtk_host->pins_1v8_drv = pinctrl_lookup_state(rtk_host->pinctrl, "sdio-1v8-drv");
+	if (IS_ERR(rtk_host->pins_1v8_drv)) {
+		rc = PTR_ERR(rtk_host->pins_1v8_drv);
+		pr_warn("fail to get pad driving for 1.8V state\n");
+		goto err_sdio_clk;
+	}
+
+	if (soc_device_match(rtk_soc_stark)) {
+		rtk_host->pins_vsel_3v3 = pinctrl_lookup_state(rtk_host->pinctrl, "sdio-vsel-3v3");
+		if (IS_ERR(rtk_host->pins_vsel_3v3)) {
+			rc = PTR_ERR(rtk_host->pins_vsel_3v3);
+			pr_warn("fail to get pad power state for 3.3V\n");
+			goto err_sdio_clk;
+		}
+
+		rtk_host->pins_vsel_1v8 = pinctrl_lookup_state(rtk_host->pinctrl, "sdio-vsel-1v8");
+		if (IS_ERR(rtk_host->pins_vsel_1v8)) {
+			rc = PTR_ERR(rtk_host->pins_vsel_1v8);
+			pr_warn("fail to get pad power state for 1.8V\n");
+			goto err_sdio_clk;
+		}
+
+		if (device_property_read_bool(&pdev->dev, "no-1-8-v"))
+			host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;
+	}
+
 	reset_control_deassert(rtk_host->rstc_sdio);
 	clk_prepare_enable(rtk_host->clk_en_sdio);
 	clk_prepare_enable(rtk_host->clk_en_sdio_ip);
 
-	rtk_sdhci_platform_init(host);
-
 	rtk_replace_mmc_host_ops(host);
 
+	sdhci_rtk_hw_init(host);
+
 	rc = mmc_of_parse(host->mmc);
 	if (rc)
 		goto err_sdio_clk;
@@ -858,7 +851,7 @@ static int __maybe_unused sdhci_rtk_susp
 
 	pr_err("[SDIO] %s start\n", __func__);
 
-	rtk_host->preset_pll = readl(crt_membase + 0x01A0);
+	rtk_host->preset_pll = readl(crt_membase + SYS_PLL_SDIO1);
 
 	sdhci_suspend_host(host);
 	reset_control_assert(rtk_host->rstc_sdio);
@@ -875,8 +868,7 @@ static int __maybe_unused sdhci_rtk_resu
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_rtk *rtk_host = sdhci_pltfm_priv(pltfm_host);
 	void __iomem *crt_membase =  rtk_host->crt_membase;
-
-	unsigned int val;
+	u8 reg;
 
 	host->clock = 0;
 
@@ -889,15 +881,11 @@ static int __maybe_unused sdhci_rtk_resu
 	sdhci_rtk_hw_init(host);
 
 	if ((host->timing == MMC_TIMING_UHS_SDR50) || (host->timing == MMC_TIMING_UHS_SDR104))
-			writel(rtk_host->preset_pll, crt_membase + 0x01A0);
-
-	if (rtk_host->location == 0)
-		writel((readl(crt_membase+0x1e0) | 0x00004000), crt_membase+0x1e0);
+		writel(rtk_host->preset_pll, crt_membase + SYS_PLL_SDIO1);
 
-	val = readl(host->ioaddr + 0x28);
-	val |= 0x0f << 8;
-	writel(val, host->ioaddr + 0x28);
-	val = readl(host->ioaddr + 0x28);
+	reg = sdhci_readb(host, SDHCI_POWER_CONTROL);
+	reg |= SDHCI_POWER_ON | SDHCI_POWER_330;
+	sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
 
 	sdhci_resume_host(host);
 
@@ -910,7 +898,7 @@ static SIMPLE_DEV_PM_OPS(sdhci_rtk_pmops
 
 static struct platform_driver sdhci_rtk_driver = {
 	.driver = {
-		.name = DRIVER_NAME,
+		.name = "sdhci-rtk",
 		.of_match_table = sdhci_rtk_dt_match,
 		.pm = &sdhci_rtk_pmops,
 		},
Index: kernel-5_15/drivers/mmc/host/sdhci-rtk.h
===================================================================
--- kernel-5_15.orig/drivers/mmc/host/sdhci-rtk.h
+++ kernel-5_15/drivers/mmc/host/sdhci-rtk.h
@@ -10,9 +10,63 @@
 
 #include "sdhci.h"
 
+#define MAX_PHASE     32
+#define TUNING_CNT      3
+#define MINIMUM_CONTINUE_LENGTH   16
 /* Controller needs to take care AXI burst boundary */
 #define RTKQUIRK_AXI_BURST_BOUNDARY	BIT(0)
+#define SDIO_LOC_0      0
+#define SDIO_LOC_1      1
 
+/* CRT register */
+#define SYS_PLL_SDIO1     0x1A0
+#define  PHRT0        BIT(1)
+#define  PHSEL0_MASK      GENMASK(7, 3)
+#define  PHSEL0_SHIFT     3
+#define  PHSEL1_MASK      GENMASK(12, 8)
+#define  PHSEL1_SHIFT     8
+#define SYS_PLL_SDIO2     0x1A4
+#define  REG_TUNE11     GENMASK(2, 1)
+#define  REG_TUNE11_1V9     0x2
+#define  SSCPLL_CS1     GENMASK(4, 3)
+#define  SSCPLL_CS1_INIT_VALUE    0x1
+#define  SSCPLL_ICP     GENMASK(9, 5)
+#define  SSCPLL_ICP_10U     0x01
+#define  SSCPLL_ICP_20U     0x03
+#define  SSCPLL_RS      GENMASK(12, 10)
+#define  SSCPLL_RS_10K      0x4
+#define  SSCPLL_RS_13K      0x5
+#define  SSC_DEPTH      GENMASK(15, 13)
+#define  SSC_DEPTH_1_N      0x3
+#define  SSC_8X_EN      BIT(16)
+#define  SSC_DIV_EXT_F      GENMASK(25, 18)
+#define  SSC_DIV_EXT_F_50M    0x71
+#define  SSC_DIV_EXT_F_100M   0xE3
+#define  SSC_DIV_EXT_F_200M   0x0
+#define  SSC_DIV_EXT_F_208M   0xE3
+#define  EN_CPNEW     BIT(26)
+#define SYS_PLL_SDIO3     0x1A8
+#define  SSC_TBASE      GENMASK(7, 0)
+#define  SSC_TBASE_INIT_VALUE   0x88
+#define  SSC_STEP_IN      GENMASK(14, 8)
+#define  SSC_STEP_IN_INIT_VALUE   0x43
+#define  SSC_DIV_N      GENMASK(25, 16)
+#define  SSC_DIV_N_50M      0x28
+#define  SSC_DIV_N_100M     0x56
+#define  SSC_DIV_N_200M     0xAE
+#define  SSC_DIV_N_208M     0xB6
+#define SYS_PLL_SDIO4     0x1AC
+#define  SSC_RSTB     BIT(0)
+#define  SSC_PLL_RSTB     BIT(1)
+#define  SSC_PLL_POW      BIT(2)
+#define SYS_PLL_SD1     0x1E0
+#define  REG_SEL3318_MASK   GENMASK(14, 13)
+#define  REG_SEL3318_3V3    0x1
+#define  REG_SEL3318_0V     0x2
+#define  REG_SEL3318_1V8    0x3
+#define SDIO_RTK_CTL      0x10A10
+#define SDIO_RTK_ISREN      0x10A34
+#define SDIO_RTK_DUMMY_SYS1   0x10A58
 void rtk_register_set(struct sdhci_host *host);
 
 #endif /* _DRIVERS_MMC_SDHCI_OF_RTK_H */
